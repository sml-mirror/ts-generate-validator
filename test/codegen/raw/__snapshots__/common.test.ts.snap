// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`codegen/raw/common create validators: generated validators at "src/generated/validators/model.ts" 1`] = `
"/* This file was automatically generated and should not be edited */
// tslint:disable
/* eslint-disable */

import {
  GeneratedValidation,
  ValidationConfig,
  PartialValidationConfig,
  ValidationError,
  ValidationException,
  ValidationType,
  Data,
  UserContext,
  getConfig,
  mergeDeep,
  typeValidator,
  TypeValidatorPayload,
  customValidator,
  equalValidator,
  equalToValidator,
  dateValidator
} from 'ts-generate-validator';

import {
  TypeValidatorWithCustomMessage,
  TypeValidatorOnNestedPropertyType,
  TypeValidatorOnAsyncNestedPropertyType,
  TypeValidatorOnAsyncDeepNestedPropertyType,
  TypeValidatorOnNullPropertyType,
  TypeValidatorOnNullPropertyWithoutType,
  TypeValidatorOnImportedEnumPropertyType,
  TypeValidatorOnUnionPropertyType,
  TypeValidatorOnUnionWithNestedPropertyType,
  TypeValidatorOnArrayPropertyType,
  TypeValidatorOnUnionWithArrayPropertyType,
  TypeValidatorOnArrayOfNestedTypePropertyType,
  CustomValidatorFailed,
  CustomValidatorSuccess,
  CustomValidatorOnNonPrimitiveStructure,
  CustomValidatorSuccessAsync,
  customValidatorFuncExportedAsync,
  CustomValidatorExportedSuccessAsync,
  CustomValidatorImported,
  customValidationFuncExported,
  CustomValidatorExported,
  CustomValidatorWhichUsesImportedEntity,
  IgnoreValidationForNonPrimitiveProperty,
  IgnoreValidationForPrimitiveProperty,
  IgnoreValidationForPrimitivePropertyWithOtherDecorators,
  EqualValidatorWithDefaultMessage,
  EqualValidatorWithCustomMessage,
  EqualValidatorForBoolean,
  EqualToValidatorWithDefaultMessage,
  DateValidatorWithDefaultMessage
} from './../../../model';

import { UserType } from './../../../../../user/type/model';

import { customValidationFuncImported, someEntityUsedInCustomValidator } from './../../../customValidationFunc';

export const validateTypeValidatorWithCustomMessage: GeneratedValidation = <
  D extends Data = typeof TypeValidatorWithCustomMessage,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        customMessage: 'type custom message',

        type: ValidationType.string,

        typeName: 'string'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnNestedPropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnNestedPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customMessage: 'type custom message',

        typeDescription: validateCustomValidatorSuccess,

        type: ValidationType.nested,

        typeName: 'CustomValidatorSuccess'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnAsyncNestedPropertyType: GeneratedValidation = async <
  D extends Data = typeof TypeValidatorOnAsyncNestedPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    async () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customMessage: 'type custom message',

        typeDescription: validateCustomValidatorSuccessAsync,

        type: ValidationType.nested,

        typeName: 'CustomValidatorSuccessAsync'
      })
  ];

  for (const validation of validationChain) {
    try {
      await validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnAsyncDeepNestedPropertyType: GeneratedValidation = async <
  D extends Data = typeof TypeValidatorOnAsyncDeepNestedPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    async () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customMessage: 'type custom message',

        typeDescription: validateTypeValidatorOnAsyncNestedPropertyType,

        type: ValidationType.nested,

        typeName: 'TypeValidatorOnAsyncNestedPropertyType'
      })
  ];

  for (const validation of validationChain) {
    try {
      await validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnNullPropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnNullPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.null,

        typeName: 'null'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnNullPropertyWithoutType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnNullPropertyWithoutType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.null,

        typeName: 'null'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnImportedEnumPropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnImportedEnumPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        typeDescription: UserType,

        type: ValidationType.enum,

        typeName: 'UserType'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnUnionPropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnUnionPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        typeDescription: [
          {
            type: 'string'
          },
          {
            type: 'number'
          },
          {
            type: 'null'
          }
        ] as TypeValidatorPayload[],

        type: ValidationType.union,

        typeName: 'string | number | null'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnUnionWithNestedPropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnUnionWithNestedPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        typeDescription: [
          {
            type: 'nested',
            typeDescription: validateCustomValidatorFailed
          },
          {
            type: 'number'
          },
          {
            type: 'null'
          }
        ] as TypeValidatorPayload[],

        type: ValidationType.union,

        typeName: 'CustomValidatorFailed | number | null'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnArrayPropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnArrayPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        typeDescription: {
          type: 'string'
        } as TypeValidatorPayload,

        type: ValidationType.array,

        typeName: 'string[]'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnUnionWithArrayPropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnUnionWithArrayPropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        typeDescription: [
          {
            type: 'null'
          },
          {
            type: 'number'
          },
          {
            type: 'array',
            typeDescription: {
              type: 'string'
            }
          }
        ] as TypeValidatorPayload[],

        type: ValidationType.union,

        typeName: 'null | number | string[]'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateTypeValidatorOnArrayOfNestedTypePropertyType: GeneratedValidation = <
  D extends Data = typeof TypeValidatorOnArrayOfNestedTypePropertyType,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        typeDescription: {
          type: 'nested',
          typeDescription: validateCustomValidatorSuccess
        } as TypeValidatorPayload,

        type: ValidationType.array,

        typeName: 'CustomValidatorSuccess[]'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorFailed: GeneratedValidation = <
  D extends Data = typeof CustomValidatorFailed,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: () => {
          throw new Error('Failed!');
        }
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorSuccess: GeneratedValidation = <
  D extends Data = typeof CustomValidatorSuccess,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: () => undefined
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorOnNonPrimitiveStructure: GeneratedValidation = <
  D extends Data = typeof CustomValidatorOnNonPrimitiveStructure,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: () => undefined
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorSuccessAsync: GeneratedValidation = async <
  D extends Data = typeof CustomValidatorSuccessAsync,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    async () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: async (): Promise<void> => new Promise((resolve) => setTimeout(() => resolve(), 300))
      })
  ];

  for (const validation of validationChain) {
    try {
      await validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorExportedSuccessAsync: GeneratedValidation = async <
  D extends Data = typeof CustomValidatorExportedSuccessAsync,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    async () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: customValidatorFuncExportedAsync
      })
  ];

  for (const validation of validationChain) {
    try {
      await validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorImported: GeneratedValidation = <
  D extends Data = typeof CustomValidatorImported,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: customValidationFuncImported
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorExported: GeneratedValidation = <
  D extends Data = typeof CustomValidatorExported,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: customValidationFuncExported
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateCustomValidatorWhichUsesImportedEntity: GeneratedValidation = <
  D extends Data = typeof CustomValidatorWhichUsesImportedEntity,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    () =>
      customValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: true,
        config,
        context,

        customValidationFunction: ({ property, propertyName }) => {
          if (property !== someEntityUsedInCustomValidator) {
            throw new ValidationError(propertyName as string, 'some error message');
          }
        }
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateIgnoreValidationForNonPrimitiveProperty: GeneratedValidation = <
  D extends Data = typeof IgnoreValidationForNonPrimitiveProperty,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateIgnoreValidationForPrimitiveProperty: GeneratedValidation = <
  D extends Data = typeof IgnoreValidationForPrimitiveProperty,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateIgnoreValidationForPrimitivePropertyWithOtherDecorators: GeneratedValidation = <
  D extends Data = typeof IgnoreValidationForPrimitivePropertyWithOtherDecorators,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateEqualValidatorWithDefaultMessage: GeneratedValidation = <
  D extends Data = typeof EqualValidatorWithDefaultMessage,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.string,

        typeName: 'string'
      }),

    () =>
      equalValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        value: 'abcdef'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateEqualValidatorWithCustomMessage: GeneratedValidation = <
  D extends Data = typeof EqualValidatorWithCustomMessage,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.number,

        typeName: 'number'
      }),

    () =>
      equalValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        value: 245,

        customMessage: 'equal custom message'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateEqualValidatorForBoolean: GeneratedValidation = <
  D extends Data = typeof EqualValidatorForBoolean,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.boolean,

        typeName: 'boolean'
      }),

    () =>
      equalValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        value: true
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateEqualToValidatorWithDefaultMessage: GeneratedValidation = <
  D extends Data = typeof EqualToValidatorWithDefaultMessage,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.string,

        typeName: 'string'
      }),

    () =>
      equalToValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        targetPropertyName: 'someOtherProperty'
      }),

    () =>
      typeValidator({
        property: data?.someOtherProperty,
        propertyName: \`\${propNamePrefix}someOtherProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.string,

        typeName: 'string'
      }),

    () =>
      equalToValidator({
        property: data?.someOtherProperty,
        propertyName: \`\${propNamePrefix}someOtherProperty\`,
        data,
        optional: false,
        config,
        context,

        targetPropertyName: 'someProperty'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};

export const validateDateValidatorWithDefaultMessage: GeneratedValidation = <
  D extends Data = typeof DateValidatorWithDefaultMessage,
  C extends UserContext = UserContext
>(
  data: D,
  configArg?: PartialValidationConfig,
  context?: C,
  propNamePrefix: string = ''
) => {
  const config = <ValidationConfig>mergeDeep({}, getConfig(), configArg ?? {});
  const errors: ValidationError[] = [];
  const validationChain = [
    () =>
      typeValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.string,

        typeName: 'string'
      }),

    () =>
      dateValidator({
        property: data?.someProperty,
        propertyName: \`\${propNamePrefix}someProperty\`,
        data,
        optional: false,
        config,
        context,

        customMessage: 'someOtherProperty'
      }),

    () =>
      typeValidator({
        property: data?.someOtherProperty,
        propertyName: \`\${propNamePrefix}someOtherProperty\`,
        data,
        optional: false,
        config,
        context,

        type: ValidationType.string,

        typeName: 'string'
      }),

    () =>
      dateValidator({
        property: data?.someOtherProperty,
        propertyName: \`\${propNamePrefix}someOtherProperty\`,
        data,
        optional: false,
        config,
        context,

        customMessage: 'someProperty'
      })
  ];

  for (const validation of validationChain) {
    try {
      validation();
    } catch (err) {
      if (err instanceof ValidationException) {
        if (config.stopAtFirstError) {
          throw err;
        }

        errors.push(...err.errors);
      } else {
        if (!(err instanceof ValidationError)) {
          throw err;
        }

        errors.push(err);

        if (config.stopAtFirstError) {
          throw new ValidationException(errors);
        }
      }
    }
  }

  if (errors.length) {
    throw new ValidationException(errors);
  }
};
"
`;

exports[`codegen/raw/common parse & prepare: data for render 1`] = `
Array [
  Object {
    "fileName": "model.ts",
    "filePath": "src/generated/validators",
    "imports": Array [
      Object {
        "clauses": "GeneratedValidation, ValidationConfig, PartialValidationConfig, ValidationError, ValidationException, ValidationType, Data, UserContext, getConfig, mergeDeep, typeValidator, TypeValidatorPayload, customValidator, equalValidator, equalToValidator, dateValidator",
        "path": "ts-generate-validator",
      },
      Object {
        "clauses": "TypeValidatorWithCustomMessage, TypeValidatorOnNestedPropertyType, TypeValidatorOnAsyncNestedPropertyType, TypeValidatorOnAsyncDeepNestedPropertyType, TypeValidatorOnNullPropertyType, TypeValidatorOnNullPropertyWithoutType, TypeValidatorOnImportedEnumPropertyType, TypeValidatorOnUnionPropertyType, TypeValidatorOnUnionWithNestedPropertyType, TypeValidatorOnArrayPropertyType, TypeValidatorOnUnionWithArrayPropertyType, TypeValidatorOnArrayOfNestedTypePropertyType, CustomValidatorFailed, CustomValidatorSuccess, CustomValidatorOnNonPrimitiveStructure, CustomValidatorSuccessAsync, customValidatorFuncExportedAsync, CustomValidatorExportedSuccessAsync, CustomValidatorImported, customValidationFuncExported, CustomValidatorExported, CustomValidatorWhichUsesImportedEntity, IgnoreValidationForNonPrimitiveProperty, IgnoreValidationForPrimitiveProperty, IgnoreValidationForPrimitivePropertyWithOtherDecorators, EqualValidatorWithDefaultMessage, EqualValidatorWithCustomMessage, EqualValidatorForBoolean, EqualToValidatorWithDefaultMessage, DateValidatorWithDefaultMessage",
        "path": "./../../../model",
      },
      Object {
        "clauses": "UserType",
        "path": "./../../../../../user/type/model",
      },
      Object {
        "clauses": "customValidationFuncImported, someEntityUsedInCustomValidator",
        "path": "./../../../customValidationFunc",
      },
    ],
    "validations": Array [
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "customMessage",
                "type": "string",
                "value": "type custom message",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.string",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorWithCustomMessage",
        "name": "validateTypeValidatorWithCustomMessage",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "customMessage",
                "type": "string",
                "value": "type custom message",
              },
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "validateCustomValidatorSuccess",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.nested",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "CustomValidatorSuccess",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnNestedPropertyType",
        "name": "validateTypeValidatorOnNestedPropertyType",
      },
      Object {
        "async": true,
        "items": Array [
          Object {
            "async": true,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "customMessage",
                "type": "string",
                "value": "type custom message",
              },
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "validateCustomValidatorSuccessAsync",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.nested",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "CustomValidatorSuccessAsync",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnAsyncNestedPropertyType",
        "name": "validateTypeValidatorOnAsyncNestedPropertyType",
      },
      Object {
        "async": true,
        "items": Array [
          Object {
            "async": true,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "customMessage",
                "type": "string",
                "value": "type custom message",
              },
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "validateTypeValidatorOnAsyncNestedPropertyType",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.nested",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "TypeValidatorOnAsyncNestedPropertyType",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnAsyncDeepNestedPropertyType",
        "name": "validateTypeValidatorOnAsyncDeepNestedPropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.null",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "null",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnNullPropertyType",
        "name": "validateTypeValidatorOnNullPropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.null",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "null",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnNullPropertyWithoutType",
        "name": "validateTypeValidatorOnNullPropertyWithoutType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "UserType",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.enum",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "UserType",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnImportedEnumPropertyType",
        "name": "validateTypeValidatorOnImportedEnumPropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "[
  {
    \\"type\\": \\"string\\"
  },
  {
    \\"type\\": \\"number\\"
  },
  {
    \\"type\\": \\"null\\"
  }
] as TypeValidatorPayload[]",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.union",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string | number | null",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnUnionPropertyType",
        "name": "validateTypeValidatorOnUnionPropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "[
  {
    \\"type\\": \\"nested\\",
    \\"typeDescription\\": \\"validateCustomValidatorFailed\\"
  },
  {
    \\"type\\": \\"number\\"
  },
  {
    \\"type\\": \\"null\\"
  }
] as TypeValidatorPayload[]",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.union",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "CustomValidatorFailed | number | null",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnUnionWithNestedPropertyType",
        "name": "validateTypeValidatorOnUnionWithNestedPropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "{
  \\"type\\": \\"string\\"
} as TypeValidatorPayload",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.array",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string[]",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnArrayPropertyType",
        "name": "validateTypeValidatorOnArrayPropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "[
  {
    \\"type\\": \\"null\\"
  },
  {
    \\"type\\": \\"number\\"
  },
  {
    \\"type\\": \\"array\\",
    \\"typeDescription\\": {
      \\"type\\": \\"string\\"
    }
  }
] as TypeValidatorPayload[]",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.union",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "null | number | string[]",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnUnionWithArrayPropertyType",
        "name": "validateTypeValidatorOnUnionWithArrayPropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "typeDescription",
                "type": "object",
                "value": "{
  \\"type\\": \\"nested\\",
  \\"typeDescription\\": \\"validateCustomValidatorSuccess\\"
} as TypeValidatorPayload",
              },
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.array",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "CustomValidatorSuccess[]",
              },
            ],
          },
        ],
        "modelClassName": "TypeValidatorOnArrayOfNestedTypePropertyType",
        "name": "validateTypeValidatorOnArrayOfNestedTypePropertyType",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": false,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "() => {
    throw new Error('Failed!');
  }",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorFailed",
        "name": "validateCustomValidatorFailed",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": false,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "() => undefined",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorSuccess",
        "name": "validateCustomValidatorSuccess",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "async": false,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "() => undefined",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorOnNonPrimitiveStructure",
        "name": "validateCustomValidatorOnNonPrimitiveStructure",
      },
      Object {
        "async": true,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": true,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "async (): Promise<void> => new Promise((resolve) => setTimeout(() => resolve(), 300))",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorSuccessAsync",
        "name": "validateCustomValidatorSuccessAsync",
      },
      Object {
        "async": true,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": true,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "customValidatorFuncExportedAsync",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorExportedSuccessAsync",
        "name": "validateCustomValidatorExportedSuccessAsync",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": false,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "customValidationFuncImported",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorImported",
        "name": "validateCustomValidatorImported",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": false,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "customValidationFuncExported",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorExported",
        "name": "validateCustomValidatorExported",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": false,
            "optional": true,
            "propertyName": "someProperty",
            "validatorName": "customValidator",
            "validatorPayload": Array [
              Object {
                "property": "customValidationFunction",
                "type": "",
                "value": "({ property, propertyName }) => {
    if (property !== someEntityUsedInCustomValidator) {
      throw new ValidationError(propertyName as string, 'some error message');
    }
  }",
              },
            ],
          },
        ],
        "modelClassName": "CustomValidatorWhichUsesImportedEntity",
        "name": "validateCustomValidatorWhichUsesImportedEntity",
      },
      Object {
        "async": false,
        "items": Array [],
        "modelClassName": "IgnoreValidationForNonPrimitiveProperty",
        "name": "validateIgnoreValidationForNonPrimitiveProperty",
      },
      Object {
        "async": false,
        "items": Array [],
        "modelClassName": "IgnoreValidationForPrimitiveProperty",
        "name": "validateIgnoreValidationForPrimitiveProperty",
      },
      Object {
        "async": false,
        "items": Array [],
        "modelClassName": "IgnoreValidationForPrimitivePropertyWithOtherDecorators",
        "name": "validateIgnoreValidationForPrimitivePropertyWithOtherDecorators",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.string",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string",
              },
            ],
          },
          Object {
            "async": false,
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "equalValidator",
            "validatorPayload": Array [
              Object {
                "property": "value",
                "type": "string",
                "value": "abcdef",
              },
            ],
          },
        ],
        "modelClassName": "EqualValidatorWithDefaultMessage",
        "name": "validateEqualValidatorWithDefaultMessage",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.number",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "number",
              },
            ],
          },
          Object {
            "async": false,
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "equalValidator",
            "validatorPayload": Array [
              Object {
                "property": "value",
                "type": "number",
                "value": "245",
              },
              Object {
                "property": "customMessage",
                "type": "string",
                "value": "equal custom message",
              },
            ],
          },
        ],
        "modelClassName": "EqualValidatorWithCustomMessage",
        "name": "validateEqualValidatorWithCustomMessage",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.boolean",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "boolean",
              },
            ],
          },
          Object {
            "async": false,
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "equalValidator",
            "validatorPayload": Array [
              Object {
                "property": "value",
                "type": "boolean",
                "value": "true",
              },
            ],
          },
        ],
        "modelClassName": "EqualValidatorForBoolean",
        "name": "validateEqualValidatorForBoolean",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.string",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string",
              },
            ],
          },
          Object {
            "async": false,
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "equalToValidator",
            "validatorPayload": Array [
              Object {
                "property": "targetPropertyName",
                "type": "string",
                "value": "someOtherProperty",
              },
            ],
          },
          Object {
            "optional": false,
            "propertyName": "someOtherProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.string",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string",
              },
            ],
          },
          Object {
            "async": false,
            "optional": false,
            "propertyName": "someOtherProperty",
            "validatorName": "equalToValidator",
            "validatorPayload": Array [
              Object {
                "property": "targetPropertyName",
                "type": "string",
                "value": "someProperty",
              },
            ],
          },
        ],
        "modelClassName": "EqualToValidatorWithDefaultMessage",
        "name": "validateEqualToValidatorWithDefaultMessage",
      },
      Object {
        "async": false,
        "items": Array [
          Object {
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.string",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string",
              },
            ],
          },
          Object {
            "async": false,
            "optional": false,
            "propertyName": "someProperty",
            "validatorName": "dateValidator",
            "validatorPayload": Array [
              Object {
                "property": "customMessage",
                "type": "string",
                "value": "someOtherProperty",
              },
            ],
          },
          Object {
            "optional": false,
            "propertyName": "someOtherProperty",
            "validatorName": "typeValidator",
            "validatorPayload": Array [
              Object {
                "property": "type",
                "type": "object",
                "value": "ValidationType.string",
              },
              Object {
                "property": "typeName",
                "type": "string",
                "value": "string",
              },
            ],
          },
          Object {
            "async": false,
            "optional": false,
            "propertyName": "someOtherProperty",
            "validatorName": "dateValidator",
            "validatorPayload": Array [
              Object {
                "property": "customMessage",
                "type": "string",
                "value": "someProperty",
              },
            ],
          },
        ],
        "modelClassName": "DateValidatorWithDefaultMessage",
        "name": "validateDateValidatorWithDefaultMessage",
      },
    ],
  },
]
`;

exports[`codegen/raw/common parse & prepare: parsed metadata 1`] = `
Array [
  Object {
    "classes": Array [],
    "functions": Array [
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "customValidationFuncImported",
      },
    ],
    "imports": Array [],
    "name": "customValidationFunc.ts",
  },
  Object {
    "classes": Array [
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "type custom message",
                ],
                "name": "TypeValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "string",
              "validationType": "string",
            },
          },
        ],
        "name": "TypeValidatorWithCustomMessage",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "type custom message",
                ],
                "name": "TypeValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "CustomValidatorSuccess",
              "referencePath": "model.ts",
              "validationType": "nested",
            },
          },
        ],
        "name": "TypeValidatorOnNestedPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "type custom message",
                ],
                "name": "TypeValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "CustomValidatorSuccessAsync",
              "referencePath": "model.ts",
              "validationType": "nested",
            },
          },
        ],
        "name": "TypeValidatorOnAsyncNestedPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "type custom message",
                ],
                "name": "TypeValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "TypeValidatorOnAsyncNestedPropertyType",
              "referencePath": "model.ts",
              "validationType": "nested",
            },
          },
        ],
        "name": "TypeValidatorOnAsyncDeepNestedPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "null",
              "validationType": "null",
            },
          },
        ],
        "name": "TypeValidatorOnNullPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "null",
              "validationType": "null",
            },
          },
        ],
        "name": "TypeValidatorOnNullPropertyWithoutType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "UserType",
              "referencePath": "../../user/type/model",
              "validationType": "enum",
            },
          },
        ],
        "name": "TypeValidatorOnImportedEnumPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "unionTypes": Array [
                Object {
                  "name": "string",
                  "validationType": "string",
                },
                Object {
                  "name": "number",
                  "validationType": "number",
                },
                Object {
                  "name": "null",
                  "validationType": "null",
                },
              ],
              "validationType": "union",
            },
          },
        ],
        "name": "TypeValidatorOnUnionPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "unionTypes": Array [
                Object {
                  "name": "CustomValidatorFailed",
                  "referencePath": "model.ts",
                  "validationType": "nested",
                },
                Object {
                  "name": "number",
                  "validationType": "number",
                },
                Object {
                  "name": "null",
                  "validationType": "null",
                },
              ],
              "validationType": "union",
            },
          },
        ],
        "name": "TypeValidatorOnUnionWithNestedPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "arrayOf": Object {
                "name": "string",
                "validationType": "string",
              },
              "validationType": "array",
            },
          },
        ],
        "name": "TypeValidatorOnArrayPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "unionTypes": Array [
                Object {
                  "name": "null",
                  "validationType": "null",
                },
                Object {
                  "name": "number",
                  "validationType": "number",
                },
                Object {
                  "arrayOf": Object {
                    "name": "string",
                    "validationType": "string",
                  },
                  "validationType": "array",
                },
              ],
              "validationType": "union",
            },
          },
        ],
        "name": "TypeValidatorOnUnionWithArrayPropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "arrayOf": Object {
                "name": "CustomValidatorSuccess",
                "referencePath": "model.ts",
                "validationType": "nested",
              },
              "validationType": "array",
            },
          },
        ],
        "name": "TypeValidatorOnArrayOfNestedTypePropertyType",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "() => {
    throw new Error('Failed!');
  }",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "CustomValidatorFailed",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "() => undefined",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "CustomValidatorSuccess",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "() => undefined",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "mock",
              "validationType": "notSupported",
            },
          },
        ],
        "name": "CustomValidatorOnNonPrimitiveStructure",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "async (): Promise<void> => new Promise((resolve) => setTimeout(() => resolve(), 300))",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "CustomValidatorSuccessAsync",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "customValidatorFuncExportedAsync",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "CustomValidatorExportedSuccessAsync",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "customValidationFuncImported",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "CustomValidatorImported",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "customValidationFuncExported",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "CustomValidatorExported",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "({ property, propertyName }) => {
    if (property !== someEntityUsedInCustomValidator) {
      throw new ValidationError(propertyName as string, 'some error message');
    }
  }",
                ],
                "name": "CustomValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "CustomValidatorWhichUsesImportedEntity",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [],
                "name": "IgnoreValidation",
              },
            ],
            "name": "someProperty",
            "optional": true,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "IgnoreValidationForNonPrimitiveProperty",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [],
                "name": "IgnoreValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "IgnoreValidationForPrimitiveProperty",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  10,
                ],
                "name": "MaxValidation",
              },
              Object {
                "arguments": Array [],
                "name": "IgnoreValidation",
              },
              Object {
                "arguments": Array [
                  2,
                ],
                "name": "MinValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "IgnoreValidationForPrimitivePropertyWithOtherDecorators",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "abcdef",
                ],
                "name": "EqualValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "string",
              "validationType": "string",
            },
          },
        ],
        "name": "EqualValidatorWithDefaultMessage",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  245,
                  "equal custom message",
                ],
                "name": "EqualValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "number",
              "validationType": "number",
            },
          },
        ],
        "name": "EqualValidatorWithCustomMessage",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  true,
                ],
                "name": "EqualValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "boolean",
              "validationType": "boolean",
            },
          },
        ],
        "name": "EqualValidatorForBoolean",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "someOtherProperty",
                ],
                "name": "EqualToValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "string",
              "validationType": "string",
            },
          },
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "someProperty",
                ],
                "name": "EqualToValidation",
              },
            ],
            "name": "someOtherProperty",
            "optional": false,
            "type": Object {
              "name": "string",
              "validationType": "string",
            },
          },
        ],
        "name": "EqualToValidatorWithDefaultMessage",
      },
      Object {
        "decorators": Array [
          Object {
            "arguments": Array [],
            "name": "Validation",
          },
        ],
        "fields": Array [
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "someOtherProperty",
                ],
                "name": "DateValidation",
              },
            ],
            "name": "someProperty",
            "optional": false,
            "type": Object {
              "name": "string",
              "validationType": "string",
            },
          },
          Object {
            "decorators": Array [
              Object {
                "arguments": Array [
                  "someProperty",
                ],
                "name": "DateValidation",
              },
            ],
            "name": "someOtherProperty",
            "optional": false,
            "type": Object {
              "name": "string",
              "validationType": "string",
            },
          },
        ],
        "name": "DateValidatorWithDefaultMessage",
      },
    ],
    "functions": Array [
      Object {
        "isAsync": true,
        "isExported": true,
        "name": "customValidatorFuncExportedAsync",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "customValidationFuncExported",
      },
    ],
    "imports": Array [
      Object {
        "absPath": "../../user/type/model",
        "clauses": Array [
          "UserType",
        ],
      },
      Object {
        "absPath": "customValidationFunc",
        "clauses": Array [
          "customValidationFuncImported",
          "someEntityUsedInCustomValidator",
        ],
      },
      Object {
        "absPath": "../../../../src/decorators",
        "clauses": Array [
          "Validation",
          "CustomValidation",
          "EqualValidation",
          "EqualToValidation",
          "IgnoreValidation",
          "TypeValidation",
          "MinValidation",
          "MaxValidation",
          "DateValidation",
        ],
      },
      Object {
        "absPath": "../../../../src",
        "clauses": Array [
          "ValidationError",
        ],
      },
    ],
    "name": "model.ts",
  },
  Object {
    "classes": Array [],
    "functions": Array [],
    "imports": Array [],
    "name": "../../user/type/model",
  },
  Object {
    "classes": Array [],
    "functions": Array [
      Object {
        "isAsync": false,
        "isExported": false,
        "name": "emptyDecorator",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "RequiredOneOfValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "TypeValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "CustomValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "IgnoreValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "EqualValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "EqualToValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "DateValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "MinValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "MaxValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "NegativeValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "PositiveValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "IntegerValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "BigIntValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "NotBigIntValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "FloatValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "LessThanValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "MoreThanValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "TrimValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "LowercaseValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "UppercaseValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "MinLengthValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "MaxLengthValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "EmailValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "UrlValidation",
      },
      Object {
        "isAsync": false,
        "isExported": true,
        "name": "MatchValidation",
      },
    ],
    "imports": Array [
      Object {
        "absPath": "../../../../validators/model",
        "clauses": Array [
          "CustomValidationFunction",
        ],
      },
      Object {
        "absPath": "../../../../codegen/model",
        "clauses": Array [
          "Data",
        ],
      },
      Object {
        "absPath": "../../../../localization/model",
        "clauses": Array [
          "Message",
        ],
      },
    ],
    "name": "../../../../src/decorators",
  },
  Object {
    "classes": Array [],
    "functions": Array [],
    "imports": Array [],
    "name": "../../../../src",
  },
]
`;
